<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTGGoldfish Scraper - Fixed Parser</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            color: white;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            color: #007AFF;
            margin-bottom: 0.5rem;
        }

        .test-controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .btn {
            background: linear-gradient(45deg, #007AFF, #5856D6);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin: 0.5rem;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: linear-gradient(45deg, #8E8E93, #636366);
        }

        .status {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #007AFF;
        }

        .status.loading {
            border-left-color: #FF9500;
        }

        .status.success {
            border-left-color: #34C759;
        }

        .status.error {
            border-left-color: #FF3B30;
        }

        .results {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 12px;
            margin-top: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .deck-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0.5rem 0;
        }

        .deck-item.rank-1 {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .deck-item.rank-2 {
            border-color: #C0C0C0;
            background: rgba(192, 192, 192, 0.1);
        }

        .deck-item.rank-3 {
            border-color: #CD7F32;
            background: rgba(205, 127, 50, 0.1);
        }

        .logs {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem 0;
        }

        .log-entry.error { color: #FF3B30; }
        .log-entry.success { color: #34C759; }
        .log-entry.info { color: #007AFF; }
        .log-entry.warning { color: #FF9500; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêü MTGGoldfish Scraper - Parser Mejorado</h1>
            <p>Versi√≥n con parsing adaptado a la estructura real de MTGGoldfish</p>
        </div>

        <div class="test-controls">
            <button class="btn" id="test-scraper">üîç Scrapear MTGGoldfish</button>
            <button class="btn secondary" id="debug-html">üîß Debug HTML</button>
            <button class="btn secondary" id="clear-cache">üóëÔ∏è Limpiar Cache</button>
        </div>

        <div id="status" class="status" style="display: none;"></div>
        <div id="results" class="results" style="display: none;"></div>

        <div class="logs">
            <h4>üìã Logs detallados</h4>
            <div id="logs-container"></div>
        </div>
    </div>

    <script>
        class MTGGoldfishFixedScraper {
            constructor() {
                this.targetUrl = 'https://www.mtggoldfish.com/metagame/standard#paper';
                this.corsProxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?',
                    'https://cors.bridged.cc/'
                ];
                this.debugMode = true;
            }

            async updateMetaData() {
                try {
                    this.log('üîç Iniciando scraping con parser mejorado...');
                    
                    for (let i = 0; i < this.corsProxies.length; i++) {
                        const proxy = this.corsProxies[i];
                        
                        try {
                            this.log(`üîó Probando proxy ${i + 1}/${this.corsProxies.length}`);
                            
                            const html = await this.fetchHTML(proxy);
                            const metaData = this.parseWithImprovedParser(html);
                            
                            if (metaData.decks.length > 0) {
                                this.log(`‚úÖ Parser exitoso: ${metaData.decks.length} mazos extra√≠dos`);
                                this.saveToCache(metaData);
                                return metaData;
                            }
                            
                        } catch (error) {
                            this.logError(`‚ùå Proxy ${i + 1} fall√≥:`, error.message);
                            continue;
                        }
                    }
                    
                    throw new Error('Todos los proxies fallaron');
                    
                } catch (error) {
                    this.logError('‚ùå Error general:', error);
                    throw error;
                }
            }

            async fetchHTML(proxy) {
                const proxyUrl = proxy + encodeURIComponent(this.targetUrl);
                this.log(`üì° Fetching: ${proxy}...`);
                
                const response = await fetch(proxyUrl, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                        'Accept': 'text/html,application/xhtml+xml',
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const html = await response.text();
                this.log(`‚úÖ HTML recibido: ${html.length} caracteres`);
                return html;
            }

            parseWithImprovedParser(html) {
                this.log('üìÑ Parseando con parser mejorado...');
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Debug detallado de la estructura
                this.analyzeHTMLStructure(doc);
                
                // Probar m√∫ltiples estrategias mejoradas
                const strategies = [
                    () => this.parseModernTable(doc),
                    () => this.parseByTextPattern(doc),
                    () => this.parseByRegexScan(doc),
                    () => this.parseFallbackMethod(doc)
                ];
                
                for (const strategy of strategies) {
                    try {
                        const decks = strategy();
                        if (decks.length > 0) {
                            return {
                                lastUpdated: new Date().toISOString(),
                                format: 'standard',
                                source: 'MTGGoldfish-Fixed',
                                deckCount: decks.length,
                                decks: decks
                            };
                        }
                    } catch (error) {
                        this.log(`‚ö†Ô∏è Estrategia fall√≥: ${error.message}`);
                        continue;
                    }
                }
                
                throw new Error('Todas las estrategias de parsing fallaron');
            }

            parseModernTable(doc) {
                this.log('üîç Parser 1: Tabla moderna de MTGGoldfish...');
                
                const decks = [];
                
                // Buscar todas las filas que contengan enlaces de arquetipo
                const rows = doc.querySelectorAll('tr');
                this.log(`üìä Analizando ${rows.length} filas...`);
                
                for (const row of rows) {
                    const archetypeLink = row.querySelector('a[href*="/archetype/standard"]');
                    if (!archetypeLink) continue;
                    
                    const deckName = this.cleanText(archetypeLink.textContent);
                    if (!deckName || deckName.length < 3) continue;
                    
                    // Buscar porcentaje en la misma fila usando patrones m√°s flexibles
                    const rowText = row.textContent;
                    const percentageMatches = [
                        rowText.match(/(\d+\.?\d*)\s*%/),
                        rowText.match(/(\d+\.?\d*)%/),
                        rowText.match(/(\d{1,2}\.\d{1,2})%/),
                        rowText.match(/(\d{1,2})%/)
                    ];
                    
                    let metaShare = null;
                    for (const match of percentageMatches) {
                        if (match) {
                            metaShare = parseFloat(match[1]);
                            if (metaShare > 0 && metaShare <= 100) break;
                        }
                    }
                    
                    if (metaShare && metaShare > 0) {
                        decks.push({
                            id: this.generateDeckId(deckName),
                            name: deckName,
                            metaShare: metaShare,
                            rank: decks.length + 1,
                            url: archetypeLink.getAttribute('href'),
                            extractedAt: new Date().toISOString()
                        });
                        
                        this.log(`üìã Extra√≠do: ${deckName} (${metaShare}%)`);
                    }
                }
                
                if (decks.length === 0) {
                    throw new Error('No se encontraron mazos en tabla moderna');
                }
                
                // Ordenar por meta share
                decks.sort((a, b) => b.metaShare - a.metaShare);
                decks.forEach((deck, index) => deck.rank = index + 1);
                
                return decks.slice(0, 15);
            }

            parseByTextPattern(doc) {
                this.log('üîç Parser 2: B√∫squeda por patrones de texto...');
                
                const decks = [];
                const allText = doc.body.textContent;
                
                // Buscar patrones como "Deck Name 15.3%"
                const patterns = [
                    /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+(\d+\.?\d*)\s*%/g,
                    /([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})\s*(\d+\.?\d*)\s*%/g
                ];
                
                for (const pattern of patterns) {
                    let match;
                    while ((match = pattern.exec(allText)) !== null) {
                        const deckName = match[1].trim();
                        const metaShare = parseFloat(match[2]);
                        
                        if (deckName.length > 3 && metaShare > 0 && metaShare <= 50) {
                            // Verificar que no sea un duplicado
                            if (!decks.some(d => d.name === deckName)) {
                                decks.push({
                                    id: this.generateDeckId(deckName),
                                    name: deckName,
                                    metaShare: metaShare,
                                    rank: decks.length + 1,
                                    extractedAt: new Date().toISOString()
                                });
                                
                                this.log(`üéØ Patr√≥n encontrado: ${deckName} (${metaShare}%)`);
                            }
                        }
                    }
                }
                
                if (decks.length === 0) {
                    throw new Error('No se encontraron patrones de texto v√°lidos');
                }
                
                return decks.slice(0, 15);
            }

            parseByRegexScan(doc) {
                this.log('üîç Parser 3: Escaneo con regex avanzado...');
                
                const decks = [];
                
                // Obtener todo el HTML como texto
                const htmlText = doc.documentElement.innerHTML;
                
                // Patrones regex m√°s espec√≠ficos para MTGGoldfish
                const deckPatterns = [
                    /"archetype\/standard[^"]*"[^>]*>([^<]+)<[^>]*>.*?(\d+\.?\d*)\s*%/gi,
                    /href="\/archetype\/standard[^"]*"[^>]*>([^<]+)<.*?(\d+\.?\d*)\s*%/gi,
                    />([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)<\/a>.*?(\d+\.?\d*)\s*%/gi
                ];
                
                for (const pattern of deckPatterns) {
                    let match;
                    while ((match = pattern.exec(htmlText)) !== null) {
                        const deckName = this.cleanText(match[1]);
                        const metaShare = parseFloat(match[2]);
                        
                        if (deckName && deckName.length > 3 && metaShare > 0 && metaShare <= 50) {
                            if (!decks.some(d => d.name === deckName)) {
                                decks.push({
                                    id: this.generateDeckId(deckName),
                                    name: deckName,
                                    metaShare: metaShare,
                                    rank: decks.length + 1,
                                    extractedAt: new Date().toISOString()
                                });
                                
                                this.log(`üîç Regex match: ${deckName} (${metaShare}%)`);
                            }
                        }
                    }
                }
                
                if (decks.length === 0) {
                    throw new Error('No se encontraron matches con regex');
                }
                
                return decks.slice(0, 15);
            }

            parseFallbackMethod(doc) {
                this.log('üîç Parser 4: M√©todo de fallback...');
                
                // Si todo falla, crear datos b√°sicos con los arquetipos encontrados
                const archetypeLinks = doc.querySelectorAll('a[href*="/archetype/standard"]');
                const decks = [];
                
                // Asignar porcentajes estimados basados en orden
                const estimatedShares = [18, 15, 12, 10, 8, 6, 5, 4, 3, 2, 2, 1, 1, 1, 1];
                
                for (let i = 0; i < Math.min(archetypeLinks.length, 15); i++) {
                    const link = archetypeLinks[i];
                    const deckName = this.cleanText(link.textContent);
                    
                    if (deckName && deckName.length > 3) {
                        decks.push({
                            id: this.generateDeckId(deckName),
                            name: deckName,
                            metaShare: estimatedShares[i] || 1,
                            rank: i + 1,
                            url: link.getAttribute('href'),
                            extractedAt: new Date().toISOString(),
                            estimated: true
                        });
                        
                        this.log(`üìä Fallback: ${deckName} (~${estimatedShares[i] || 1}%)`);
                    }
                }
                
                if (decks.length === 0) {
                    throw new Error('M√©todo de fallback tambi√©n fall√≥');
                }
                
                this.log('‚ö†Ô∏è Usando porcentajes estimados (m√©todo fallback)');
                return decks;
            }

            analyzeHTMLStructure(doc) {
                this.log('üîç An√°lisis detallado de HTML...');
                
                const tables = doc.querySelectorAll('table');
                const archetypeLinks = doc.querySelectorAll('a[href*="/archetype/"]');
                const standardLinks = doc.querySelectorAll('a[href*="/archetype/standard"]');
                
                this.log(`üìä Estructura encontrada:`);
                this.log(`  - Tablas totales: ${tables.length}`);
                this.log(`  - Enlaces de arquetipo: ${archetypeLinks.length}`);
                this.log(`  - Enlaces Standard: ${standardLinks.length}`);
                
                // Mostrar algunos ejemplos de enlaces Standard
                if (standardLinks.length > 0) {
                    this.log(`üîó Ejemplos de mazos Standard encontrados:`);
                    for (let i = 0; i < Math.min(5, standardLinks.length); i++) {
                        const link = standardLinks[i];
                        const name = this.cleanText(link.textContent);
                        const href = link.getAttribute('href');
                        this.log(`  ${i + 1}. "${name}" -> ${href}`);
                    }
                }
                
                // Analizar contenido de texto para porcentajes
                const bodyText = doc.body.textContent;
                const percentageMatches = bodyText.match(/\d+\.?\d*\s*%/g) || [];
                this.log(`üìä Porcentajes encontrados en texto: ${percentageMatches.length}`);
                if (percentageMatches.length > 0) {
                    this.log(`  Ejemplos: ${percentageMatches.slice(0, 10).join(', ')}`);
                }
            }

            debugHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                this.analyzeHTMLStructure(doc);
                
                // Mostrar fragmento del HTML
                this.log('üìÑ Fragmento del HTML recibido:');
                const fragment = html.substring(0, 2000) + '...';
                console.log(fragment);
                
                return doc;
            }

            cleanText(text) {
                if (!text) return '';
                return text.trim().replace(/\s+/g, ' ').replace(/[^\w\s\-'.,]/g, '').trim();
            }

            generateDeckId(name) {
                return name.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, '-').substring(0, 50);
            }

            saveToCache(data) {
                try {
                    localStorage.setItem('mtgArenaSniffer_fixedMetaData', JSON.stringify(data));
                    this.log('üíæ Datos guardados en cache');
                } catch (error) {
                    this.logError('Error guardando cache:', error);
                }
            }

            loadCachedData() {
                try {
                    const cached = localStorage.getItem('mtgArenaSniffer_fixedMetaData');
                    return cached ? JSON.parse(cached) : null;
                } catch (error) {
                    return null;
                }
            }

            log(message) {
                console.log(`üêü [FixedScraper] ${message}`);
                addLog(message, 'info');
            }

            logError(message, error = null) {
                console.error(`‚ùå [FixedScraper] ${message}`, error || '');
                addLog(`${message}`, 'error');
            }
        }

        // Variables globales
        let scraper = null;
        let logs = [];

        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            logs.push({ timestamp, message, type });
            
            const logsContainer = document.getElementById('logs-container');
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${type}`;
            logElement.textContent = `[${timestamp}] ${message}`;
            
            logsContainer.appendChild(logElement);
            logsContainer.scrollTop = logsContainer.scrollHeight;
            
            if (logs.length > 100) {
                logs.shift();
                if (logsContainer.children.length > 100) {
                    logsContainer.removeChild(logsContainer.firstChild);
                }
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.style.display = 'block';
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        function showResults(metaData) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'block';
            
            resultsDiv.innerHTML = `
                <h3>üìä Mazos extra√≠dos del meta Standard</h3>
                <p><strong>Total:</strong> ${metaData.deckCount} mazos | <strong>Fuente:</strong> ${metaData.source}</p>
                <div class="deck-list">
                    ${metaData.decks.map(deck => `
                        <div class="deck-item rank-${deck.rank <= 3 ? deck.rank : ''}">
                            <div>
                                <strong>${deck.name}</strong>
                                <small style="display: block; color: #8E8E93;">
                                    ${deck.url ? `<a href="https://www.mtggoldfish.com${deck.url}" target="_blank" style="color: #007AFF;">Ver en MTGGoldfish ‚Üó</a>` : ''}
                                    ${deck.estimated ? ' (porcentaje estimado)' : ''}
                                </small>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.25rem; font-weight: bold; color: #34C759;">${deck.metaShare}%</div>
                                <div style="font-size: 0.75rem; background: #007AFF; color: white; padding: 0.25rem 0.5rem; border-radius: 4px;">
                                    #${deck.rank}
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        async function testScraper() {
            if (!scraper) return;
            
            try {
                showStatus('üîç Scrapeando con parser mejorado...', 'loading');
                document.getElementById('test-scraper').disabled = true;
                
                const metaData = await scraper.updateMetaData();
                
                if (metaData && metaData.decks.length > 0) {
                    showStatus(`‚úÖ ¬°√âXITO! ${metaData.decks.length} mazos extra√≠dos`, 'success');
                    addLog(`‚úÖ Parser exitoso: ${metaData.decks.length} mazos del meta Standard`, 'success');
                    
                    addLog('üèÜ Top 5 mazos encontrados:', 'success');
                    metaData.decks.slice(0, 5).forEach((deck, i) => {
                        addLog(`  ${i + 1}. ${deck.name} (${deck.metaShare}%)`, 'success');
                    });
                    
                    showResults(metaData);
                } else {
                    throw new Error('No se pudieron extraer mazos');
                }
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
                addLog(`‚ùå Error en scraping: ${error.message}`, 'error');
            } finally {
                document.getElementById('test-scraper').disabled = false;
            }
        }

        async function debugHTML() {
            if (!scraper) return;
            
            try {
                addLog('üîß Iniciando debug detallado del HTML...', 'info');
                
                const proxy = scraper.corsProxies[0];
                const html = await scraper.fetchHTML(proxy);
                
                const doc = scraper.debugHTML(html);
                
                addLog('üîß Debug completado - revisa la consola para detalles', 'info');
                
            } catch (error) {
                addLog(`‚ùå Error en debug: ${error.message}`, 'error');
            }
        }

        function clearCache() {
            localStorage.removeItem('mtgArenaSniffer_fixedMetaData');
            addLog('üóëÔ∏è Cache limpiado', 'success');
            document.getElementById('results').style.display = 'none';
        }

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', () => {
            addLog('üöÄ Inicializando scraper con parser mejorado...', 'info');
            scraper = new MTGGoldfishFixedScraper();
            addLog('‚úÖ Scraper listo - probar√° 4 m√©todos diferentes de parsing', 'success');
        });

        // Event listeners
        document.getElementById('test-scraper').addEventListener('click', testScraper);
        document.getElementById('debug-html').addEventListener('click', debugHTML);
        document.getElementById('clear-cache').addEventListener('click', clearCache);

        // Funciones globales
        window.testScraper = testScraper;
        window.debugHTML = debugHTML;
        window.getScraper = () => scraper;

    </script>
</body>
</html>