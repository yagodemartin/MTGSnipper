<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Arena Sniffer - Diagn√≥stico</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            color: white;
            padding: 1rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .status {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 4px solid #007AFF;
        }

        .status.error {
            border-left-color: #FF3B30;
        }

        .status.success {
            border-left-color: #34C759;
        }

        .status.warning {
            border-left-color: #FF9500;
        }

        .console {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-line {
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .log-info { color: #00ff88; }
        .log-error { color: #ff4444; }
        .log-warn { color: #ffaa00; }
        .log-success { color: #00ff00; }

        .timestamp {
            color: #666;
            margin-right: 8px;
        }

        .btn {
            background: linear-gradient(45deg, #007AFF, #5856D6);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin: 0.5rem;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
        }

        .btn.secondary {
            background: linear-gradient(45deg, #8E8E93, #636366);
        }

        .controls {
            margin: 1rem 0;
            text-align: center;
        }

        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .test-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .test-card h3 {
            color: #007AFF;
            margin-bottom: 0.5rem;
        }

        .test-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .test-status.pass { background: #34C759; color: white; }
        .test-status.fail { background: #FF3B30; color: white; }
        .test-status.pending { background: #FF9500; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç MTG Arena Sniffer - Diagn√≥stico</h1>
            <p>Verificando sistema y conectividad</p>
        </div>

        <div id="main-status" class="status">
            <strong>Estado:</strong> <span id="status-text">Iniciando diagn√≥stico...</span>
        </div>

        <div class="controls">
            <button class="btn" onclick="runFullDiagnostic()">üîß Diagn√≥stico Completo</button>
            <button class="btn secondary" onclick="testScraper()">üêü Test Scraper</button>
            <button class="btn secondary" onclick="testProxies()">üîó Test Proxies</button>
            <button class="btn secondary" onclick="clearLogs()">üóëÔ∏è Limpiar Logs</button>
        </div>

        <div class="test-results" id="test-results">
            <!-- Los resultados aparecer√°n aqu√≠ -->
        </div>

        <div class="console" id="console">
            <div class="log-line log-info">
                <span class="timestamp">[00:00:00]</span>
                üöÄ Sistema de diagn√≥stico iniciado
            </div>
        </div>
    </div>

    <script>
        // Sistema de logging simple
        class DiagnosticLogger {
            constructor() {
                this.logs = [];
                this.startTime = Date.now();
                this.consoleElement = document.getElementById('console');
            }

            log(type, message) {
                const timestamp = this.getTimestamp();
                const logEntry = { timestamp, type, message };
                this.logs.push(logEntry);

                const logLine = document.createElement('div');
                logLine.className = `log-line log-${type}`;
                logLine.innerHTML = `
                    <span class="timestamp">[${timestamp}]</span>
                    ${message}
                `;

                this.consoleElement.appendChild(logLine);
                this.consoleElement.scrollTop = this.consoleElement.scrollHeight;
            }

            getTimestamp() {
                const elapsed = Date.now() - this.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                const ms = Math.floor((elapsed % 1000) / 10);
                
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
            }

            clear() {
                this.logs = [];
                this.consoleElement.innerHTML = `
                    <div class="log-line log-info">
                        <span class="timestamp">[${this.getTimestamp()}]</span>
                        üóëÔ∏è Logs limpiados
                    </div>
                `;
            }
        }

        // Scraper de prueba simplificado
        class TestScraper {
            constructor(logger) {
                this.logger = logger;
                this.corsProxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?',
                    'https://cors.bridged.cc/',
                    'https://thingproxy.freeboard.io/fetch/',
                    'https://api.allorigins.win/get?url='
                ];
            }

            async testMTGGoldfish() {
                this.logger.log('info', 'üêü Iniciando test de MTGGoldfish...');
                
                const targetUrl = 'https://www.mtggoldfish.com/metagame/standard/full#paper';
                this.logger.log('info', `üéØ URL objetivo: ${targetUrl}`);

                for (let i = 0; i < this.corsProxies.length; i++) {
                    const proxy = this.corsProxies[i];
                    
                    try {
                        this.logger.log('info', `üîó Probando proxy ${i + 1}/${this.corsProxies.length}: ${proxy.split('//')[1]?.split('/')[0]}`);
                        
                        const proxyUrl = proxy + encodeURIComponent(targetUrl);

                        const response = await Promise.race([
                            fetch(proxyUrl, {
                                headers: {
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                                    'Accept': 'text/html,application/xhtml+xml',
                                }
                            }),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout despu√©s de 15 segundos')), 15000)
                            )
                        ]);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        let html;
                        const contentType = response.headers.get('content-type') || '';
                        
                        if (contentType.includes('application/json')) {
                            const data = await response.json();
                            html = data.contents || data.data || data.body || '';
                        } else {
                            html = await response.text();
                        }

                        if (!html || html.length < 500) {
                            throw new Error(`Respuesta muy corta: ${html?.length || 0} caracteres`);
                        }

                        this.logger.log('success', `‚úÖ Proxy exitoso: ${html.length} caracteres recibidos`);
                        
                        // Intentar parsear mazos
                        const decks = this.parseDecks(html);
                        this.logger.log('success', `üìã Mazos encontrados: ${decks.length}`);
                        
                        if (decks.length > 0) {
                            decks.slice(0, 5).forEach((deck, index) => {
                                this.logger.log('info', `  ${index + 1}. ${deck.name} (${deck.metaShare}%)`);
                            });
                        }

                        return { success: true, proxy, html, decks };

                    } catch (error) {
                        this.logger.log('error', `‚ùå Proxy ${i + 1} fall√≥: ${error.message}`);
                        continue;
                    }
                }

                this.logger.log('error', '‚ùå Todos los proxies fallaron');
                return { success: false, error: 'Todos los proxies fallaron' };
            }

            parseDecks(html) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    const decks = [];
                    const rows = doc.querySelectorAll('tr');
                    
                    this.logger.log('info', `üìä Analizando ${rows.length} filas HTML...`);

                    for (const row of rows) {
                        const archetypeLink = row.querySelector('a[href*="/archetype/standard"], a[href*="/archetype/"]');
                        if (!archetypeLink) continue;
                        
                        const deckName = this.cleanText(archetypeLink.textContent);
                        if (!deckName || deckName.length < 3) continue;
                        
                        const percentageMatch = row.textContent.match(/(\d+\.?\d*)\s*%/);
                        if (!percentageMatch) continue;
                        
                        const metaShare = parseFloat(percentageMatch[1]);
                        if (metaShare <= 0 || metaShare > 50) continue;
                        
                        decks.push({
                            name: deckName,
                            metaShare: metaShare,
                            url: archetypeLink.getAttribute('href')
                        });
                        
                        this.logger.log('info', `üìã Deck v√°lido: ${deckName} (${metaShare}%)`);
                    }

                    return decks.sort((a, b) => b.metaShare - a.metaShare);

                } catch (error) {
                    this.logger.log('error', `‚ùå Error parseando HTML: ${error.message}`);
                    return [];
                }
            }

            cleanText(text) {
                if (!text) return '';
                return text.trim().replace(/\s+/g, ' ').replace(/[^\w\s\-'.,]/g, '').trim();
            }

            async testProxy(proxy) {
                try {
                    const testUrl = 'https://httpbin.org/json';
                    const proxyUrl = proxy + encodeURIComponent(testUrl);
                    
                    const response = await Promise.race([
                        fetch(proxyUrl),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), 10000)
                        )
                    ]);

                    if (response.ok) {
                        return { success: true, status: response.status };
                    } else {
                        return { success: false, error: `HTTP ${response.status}` };
                    }

                } catch (error) {
                    return { success: false, error: error.message };
                }
            }
        }

        // Variables globales
        let logger;
        let scraper;

        // Funciones de diagn√≥stico
        async function runFullDiagnostic() {
            updateStatus('üîß Ejecutando diagn√≥stico completo...', 'warning');
            
            const results = [];

            // Test 1: Navegador
            logger.log('info', 'üåê Verificando capacidades del navegador...');
            const browserTest = testBrowser();
            results.push(browserTest);

            // Test 2: Conectividad b√°sica
            logger.log('info', 'üåç Verificando conectividad b√°sica...');
            const connectivityTest = await testConnectivity();
            results.push(connectivityTest);

            // Test 3: Proxies CORS
            logger.log('info', 'üîó Verificando proxies CORS...');
            const proxyTest = await testAllProxies();
            results.push(proxyTest);

            // Test 4: MTGGoldfish
            logger.log('info', 'üêü Verificando acceso a MTGGoldfish...');
            const mtgTest = await testMTGGoldfishAccess();
            results.push(mtgTest);

            displayResults(results);
            
            const passedTests = results.filter(r => r.status === 'pass').length;
            const totalTests = results.length;
            
            if (passedTests === totalTests) {
                updateStatus(`‚úÖ Diagn√≥stico completo: ${passedTests}/${totalTests} tests pasaron`, 'success');
            } else {
                updateStatus(`‚ö†Ô∏è Diagn√≥stico completo: ${passedTests}/${totalTests} tests pasaron`, 'warning');
            }
        }

        function testBrowser() {
            const capabilities = {
                fetch: typeof fetch !== 'undefined',
                localStorage: typeof localStorage !== 'undefined',
                modules: typeof Symbol !== 'undefined',
                domParser: typeof DOMParser !== 'undefined',
                promises: typeof Promise !== 'undefined'
            };

            const passed = Object.values(capabilities).every(Boolean);
            
            logger.log(passed ? 'success' : 'error', 
                `Navegador: ${passed ? 'Compatible' : 'Incompatible'}`);

            return {
                name: 'Compatibilidad del Navegador',
                status: passed ? 'pass' : 'fail',
                details: Object.entries(capabilities)
                    .map(([key, value]) => `${key}: ${value ? '‚úÖ' : '‚ùå'}`)
                    .join(', ')
            };
        }

        async function testConnectivity() {
            try {
                const response = await Promise.race([
                    fetch('https://httpbin.org/json'),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout despu√©s de 5 segundos')), 5000)
                    )
                ]);
                
                if (response.ok) {
                    logger.log('success', 'üåç Conectividad b√°sica: OK');
                    return {
                        name: 'Conectividad B√°sica',
                        status: 'pass',
                        details: `HTTP ${response.status} - Conexi√≥n exitosa`
                    };
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                logger.log('error', `üåç Conectividad b√°sica: FALLO - ${error.message}`);
                return {
                    name: 'Conectividad B√°sica',
                    status: 'fail',
                    details: error.message
                };
            }
        }

        async function testAllProxies() {
            const proxies = scraper.corsProxies;
            let workingProxies = 0;
            
            for (let i = 0; i < proxies.length; i++) {
                const proxy = proxies[i];
                const result = await scraper.testProxy(proxy);
                
                if (result.success) {
                    workingProxies++;
                    logger.log('success', `‚úÖ Proxy ${i + 1}: OK`);
                } else {
                    logger.log('error', `‚ùå Proxy ${i + 1}: ${result.error}`);
                }
            }

            const passed = workingProxies > 0;
            
            return {
                name: 'Proxies CORS',
                status: passed ? 'pass' : 'fail',
                details: `${workingProxies}/${proxies.length} proxies funcionando`
            };
        }

        async function testMTGGoldfishAccess() {
            try {
                const result = await scraper.testMTGGoldfish();
                
                return {
                    name: 'Acceso a MTGGoldfish',
                    status: result.success ? 'pass' : 'fail',
                    details: result.success ? 
                        `${result.decks?.length || 0} mazos encontrados` : 
                        result.error
                };
            } catch (error) {
                return {
                    name: 'Acceso a MTGGoldfish',
                    status: 'fail',
                    details: error.message
                };
            }
        }

        function displayResults(results) {
            const container = document.getElementById('test-results');
            container.innerHTML = results.map(result => `
                <div class="test-card">
                    <h3>${result.name}</h3>
                    <div class="test-status ${result.status}">${result.status.toUpperCase()}</div>
                    <p>${result.details}</p>
                </div>
            `).join('');
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('main-status');
            const textElement = document.getElementById('status-text');
            
            statusElement.className = `status ${type}`;
            textElement.textContent = message;
        }

        // Funciones de control
        async function testScraper() {
            updateStatus('üêü Probando scraper...', 'warning');
            await scraper.testMTGGoldfish();
        }

        async function testProxies() {
            updateStatus('üîó Probando proxies...', 'warning');
            await testAllProxies();
        }

        function clearLogs() {
            logger.clear();
        }

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', () => {
            logger = new DiagnosticLogger();
            scraper = new TestScraper(logger);
            
            logger.log('success', '‚úÖ Sistema de diagn√≥stico listo');
            logger.log('info', 'üí° Haz clic en "Diagn√≥stico Completo" para comenzar');
            
            updateStatus('Sistema listo - Haz clic en Diagn√≥stico Completo', 'success');
        });

        // Hacer funciones disponibles globalmente
        window.runFullDiagnostic = runFullDiagnostic;
        window.testScraper = testScraper;
        window.testProxies = testProxies;
        window.clearLogs = clearLogs;
    </script>
</body>
</html>